# Static

Ключевое слово static в Java используется для создания статических полей, методов и блоков. Статические элементы связаны с классом, а не с объектом класса, и доступны для использования без создания экземпляра класса.

 - Статические поля: статическое поле - это общее для всех экземпляров класса значение переменной, которое может быть использовано без создания экземпляра класса. Объявление статического поля делается с использованием ключевого слова static перед типом данных поля.

 - Статические методы: статический метод - это метод, который может быть вызван без создания экземпляра класса. Объявление статического метода делается с использованием ключевого слова static перед возвращаемым типом метода.

 - Статический блок: статический блок - это блок кода, который выполняется при первой загрузке класса в память. Он используется для инициализации статических полей и может быть использован для выполнения других операций, которые нужно выполнить при загрузке класса.


Пример:
```
public class StaticExample {
    static  int i = 5;
    int j;

    static {
        i = 6;
        System.out.println("static init");
    }

    {
        System.out.println("init");
    }

    {
        System.out.println("second init");
    }

    StaticExample() {
        System.out.println("Constructor");
    }

    static void staticMethod() {
        System.out.println("static method");
    }

}
```

Метод main:
```
    public static void main(String[] args) {
        System.out.println("\nAnother:");
        System.out.println(StaticExample.i);
        StaticExample.staticMethod();

        new StaticExample();
    }
```

Рассмотри сложный и интересный пример:
```
public class Main {
    static Main main = new Main();
    static int n = 4;
    static int i = returnIntStatic();

    static int k = 3;
    int j = returnInt();

    static {
        System.out.println("Static");
    }
    {
        System.out.println("clean");
    }
    Main() {
        System.out.println("construct");
    }

    static int returnIntStatic() {
        System.out.println(n);
        System.out.println(k);
        System.out.println("return static int");
        return 1;
    }

    int returnInt() {
        System.out.println("return int");
        return 2;
    }

    public static void main(String[] args) {
        // hard example about Main class
        System.out.println("Hard example");
        new Main();
    }
}
```

Вывод будет следующий:
```
return int
clean
construct
4
0
return static int
Static
Hard example
return int
clean
construct
```

**Обьяснение**: 
Для начала нужно знать что статические методы и поля инициализируються при первом попадании в память. То есть только при **первом** создании экземляра класса. Для этого мы используем **new**. Но при запуске программы JVM автоматически ищет главный класс и запускает в нем метод **main** и в этом этапе "под капотом" начинается инициализация класса которая включает в себя инициализацию статических переменных и выполнение статических блоков.

Таким образом, если вернуться к примеру, то JVM достиг функции **main** и под капотом создался экземпляр этого класса и теперь идет инициализация всех частей класса. Сначала мы попадаем к строчке **static Main main = new Main();**. Начинается ее выполнение за счет чего мы снова возвращаемся в этот класс но в этот раз уже не смотрим на статичесике поля, так как считается что они уже проинициализированы на первом этапе и таким образом начинается инициализация обычных переменных. В нашем случае **int j = returnInt();** за счет чего мы идем в указанную функцию и первым выводом на экран будет:
```
return int
```
Переменные закончились. Теперь начинается выполнение инициализаторов и конструктора за счет чего следующий вызов будет:
```
clean
construct
```

На этом этапе с первой строчкой закончили. Переходим к следующей **static int n = 4;**. Тут без выводом на экран. Идем дальше **static int i = returnIntStatic();**. Переходим в эту функцию за счет чего теперь вывод на экран будет следующим:
```
4
0
return static int
```

Вывелось значение переменной n и k, но k равняеться нулю и это правильно. Потому что мы еще не дошли до ее инициализации, за счет чего она равняется нулю.

Идем дальше. **static int k = 3** выполняется без вывода на экран. 

На данном этапе мы закончили с инициализацией статических полей, переходим к статическому инициализатору, у нас он есть. За счет чего следующий вывод будет:
```
Static
```

Теперь мы полностью закончили с и статической инициализацией. Теперь переходим в тело метода и выводим следующую строчку:
```
System.out.println("Hard example");
```

Соответственно вывод:
```
Hard example
```

Теперь переходим к следующей строчке, а именно создание нового экземпляра главного класса. Так как статическая инициализация уже произошла, то все статическое мы уже не трогаем и переходим к следующему этапу, а именно инициализации переменых. В нашем случае **int j = returnInt();**. Переходим в этот метод за счет чего получаем вывод:

```
return int
```

С переменными покончено, осталось выполнить обычные инициализаторы и конструктор за счет чего получаем вывод:
```
clean
construct
```

Это был пример того в какой последовательности все выполняется, за счет чего можно сделать такую приоритетность:

1) Статические переменные.
2) Статический инициализатор.
3) Обычные переменные.
4) Обычный инициализатор.
5) Конструктор.
