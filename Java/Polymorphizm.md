# Полиморизм

Полиморфизм в Java - это возможность объектов разных классов использовать одинаковые методы с одинаковыми именами, но с разной реализацией. Это позволяет программистам создавать более гибкие и модульные программы, которые могут работать с разными типами данных и объектами без необходимости создавать различные версии кода для каждого типа.

В Java есть два типа полиморфизма: статический и динамический. Статический полиморфизм достигается через перегрузку методов, которая позволяет создавать несколько методов с одинаковым именем, но разными параметрами. Динамический полиморфизм достигается через наследование и переопределение методов. В этом случае объекты могут использовать методы родительского класса или их переопределенные версии в зависимости от контекста.

### Динамический полиморфизм

Пример: 
```
public class Figure {

    double getPerimeter() {
        return 0;
    }
}
```
У нас есть родительский класс **Figure** с методом для получения периметра. В данном методе мы просто возвращаем ноль. 

```
public class Circle extends Figure{

    int r = 10;

    @Override
    double getPerimeter() {
        return 2 * Math.PI * r;
    }
}
```

После чего мы определяем дочерний класс Круг который наследуем от фигуры. Ключевой фрагмент в том что мы переопределяем метод получить периметр через анотацию **@Override**. Сам по себе эта анотация нужна только для того что бы в случае ошибки переопределния мы об этом узнали.

```
public class Square extends Figure{

    int a = 5;

    @Override
    double getPerimeter() {
        return a * 4;
    }
}
```

Делаем с новым класом Квадрат то же самое что и с классом Круг.


```
    public static void main(String[] args) {
        Figure figure = new Figure();
        Figure circle = new Circle();
        Figure square = new Square();

        System.out.println(figure.getPerimeter());
        System.out.println(circle.getPerimeter());
        System.out.println(square.getPerimeter());
    }
```

После чего в главном методе создаем 3 обьекта типа **Figure**, но при этом помещяем туда дочерние обьекты за счет чего теперь когда будет выполняться этот код, то во время выполнения Java сама определяет метод какого класса будет использоваться. Это и есть полиморфизм.  

### Статический полиморфизм

Пример:
```
public class Calculator {

    public static int add(int x, int y) {
        return x + y;
    }

    public static double add(double x, double y) {
        return x + y;
    }
}
```

Сначала определяем наш класс с двумя одинаковыми методами по имени но разными по функционалу, в даном случае по возвращаемому значению. В данном случае используется перегрузка методов.

```
    public static void main(String[] args) {
        System.out.println(Calculator.add(5,10));
        System.out.println(Calculator.add(15.34, 30.23));
    }
```

Теперь вызываем эти методы. Как мы видим, вызываються оба метода в зависимости от передаваемых параметров. То есть Java смотрит на передаваемые параметры и за счет этого сама определяет какой метод вызвать.