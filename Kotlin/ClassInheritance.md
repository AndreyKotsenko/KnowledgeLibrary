# Наследование
Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это базовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И производный класс (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.

Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию open. По умолчанию без этой аннотации класс не может быть унаследован.
```
open class базовый_класс
class производный_класс: базовый_класс
```
Для установки наследования после названия производного класса идет двоеточие и затем указывает класс, от которого идет наследование.
```
open class Person{
    var name: String = "Undefined"
    fun printName(){
        println(name)
    }
}
class Employee: Person()
```

Например, в данном случае класс Person представляет человека, который имеет свойство name (имя человека) и метод printName() для вывода информации о человеке. Класс Employee представляет условного работника. Поскольку работник является человеком, то класс работника будет разделять общий функционал с классом человека. Поэтому вместо того, чтобы заново определять в классе Employee свойство name, лучше уснаследовать весь функционал класса Person. То есть в данном случае класс Person является базовым или суперклассом, а класс Employee - производным классом или классом-наследником.
Но стоит учитывать, что при наследовании производный класс должен вызывать первичный конструктор (а если такого нет, то конструктор по умолчанию) базового класса.

Здесь класс Person явным образом не определяет первичных конструкторов, поэтому в классе Employee надо вызывать конструктор по умолчанию для класса Person

Вызвать конструктор базового класса в производном классе можно двумя способами. Первый способ - после двоеточия сразу указать вызов конструктора базового класса:
```
class Employee: Person()
```
Здесь запись Person() как раз представляет вызов конструктора по умолчанию класса Person.

Второй способ вызвать конструктор базового класса - определить в производном классе вторичный конструктор и в нем вызвать конструктор базового класса с помощью ключевого слова super:
```
open class Person{
    var name: String = "Undefined"
    fun printName(){
        println(name)
    }
}
class Employee: Person{
 
    constructor() : super(){
         
    }
}
```
Здесь с помощью ключевого слова constructor в классе Employee определяется вторичный конструктор. А после списка его параметров после двоеточия идет обращение к конструктору базового класса: constructor() : super(). То есть здесь вызов super() - это и есть вызов конструктора базового класса.

Вне зависимости какой способ будет выбран, далее мы сможем создавать объекты класса Employee и использовать для него уснаследованный от класса Person функционал:
```
fun main() {
 
    val bob: Employee = Employee()
    bob.name = "Bob"
    bob.printName()
}
open class Person{
    var name: String = "Undefined"
    fun printName(){
        println(name)
    }
}
class Employee: Person()
```


Если базовый класс явным образом определяет конструктор (первичный или вторичный), то производный класс должен вызывать этот конструктор. Для вызова конструктора базового в производном применяются те ж способы.

Первый способ - вызвать конструктор после названия класса через двоеточие:
```
open class Person(val name: String){
    fun printName(){
        println(name)
    }
}
class Employee(empName: String): Person(empName)
```
В данном случае класс Person через конструктор устанавливает свойство name. Поэтому в классе Employee тоже определен конструктор, который принимает стороковое значение и передает его в конструктор Person.

Если производный класс не имеет явного первичного конструктора, тогда при вызове вторичного конструктора должен вызываться конструктор базового класса через ключевое слово super:
```
open class Person(val name: String){
    fun printName(){
        println(name)
    }
}
class Employee: Person{
 
    constructor(empName: String) : super(empName){}
}
```
Опять же, поскольку конструктор Person принимает один параметр, то в super() нам надо передать значение для этого параметра.

Применение классов:
```
fun main() {
 
    val bob = Employee("Bob")
    bob.printName()
}
 
open class Person(val name: String){
    fun printName(){
        println(name)
    }
}
class Employee(empName: String): Person(empName)
```

Выше рассматривался случай, когда в базовом классе определен первичный конструктор.Но все то же действует и в том случае, если в базовом классе есть только вторичные конструкторы:
```
fun main() {
 
    val bob = Employee("Bob")
    bob.printName()
}
 
open class Person{
 
    val name: String
    constructor(userName: String){
        name = userName
    }
    fun printName(){
        println(name)
    }
}
class Employee(empName: String): Person(empName)
```

Производный класс наследует функционал от базового класса, но также может определять и свой собственный функционал:
```
fun main() {
 
    val bob = Employee("Bob", "JetBrains")
    bob.printName()
    bob.printCompany()
}
 
open class Person(val name: String){
    fun printName(){
        println(name)
    }
}
class Employee(empName: String, val company: String): Person(empName){
 
    fun printCompany(){
        println(company)
    }
}
```

В данном случае класс Employee добаваляет к унаследованному функционалу свойство company, которое хранит компанию работника, и функцию printCompany().

Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается.

Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any. Поэтому все классы по умолчанию уже будут иметь такие функции как equals, toString, hashcode.

### Перечисления enums
Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова enum class. Например, определим перечисление:
```
enum class Day{
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```
Данное перечисление Day представляет день недели. Внутри перечисления определяются константы. В данном случае это названия семи дней недели. Константы определяются через запятую. Каждая константа фактически представляет объект данного перечисления.
```
fun main() {
 
    val day: Day = Day.FRIDAY
    println(day)            // FRIDAY
    println(Day.MONDAY)     // MONDAY
}
```
Классы перечислений как и обычные классы также могут иметь конструктор. Кроме того, для констант перечисления также может вызываться конструктор для их инициализации.
```
enum class Day(val value: Int){
    MONDAY(1), TUESDAY(2), WEDNESDAY(3),
    THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(100500)
}
 
fun main() {
 
    val day: Day = Day.FRIDAY
    println(day.value)        // 5
    println(Day.MONDAY.value) // 1
}
```
В примере выше у класса перечисления через конструктор определяется свойство value. Соответственно при определении констант перечисления необходимо каждую из этих констант инициализировать, передав значение для свойства value.

При этом перечисления - это не просто список значений. Они могут определять также свойства и функции. Но если класс перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой.
```
enum class Day(val value: Int){
    MONDAY(1), TUESDAY(2), WEDNESDAY(3),
    THURSDAY(4), FRIDAY(5), SATURDAY(6),
    SUNDAY(7);
    fun getDuration(day: Day): Int{
        return value - day.value;
    }
}
 
fun main() {
 
    val day1: Day = Day.FRIDAY
    val day2: Day = Day.MONDAY
    println(day1.getDuration(day2))        // 4
}
```
В данном случае в перечислении определена функция getDuration(), которая вычисляет разницу в днях между двумя днями недели.

#### Встроенные свойства и вспомогательные методы

Все перечисления обладают двумя встроенными свойствами:

 - **name**: возвращает название константы в виде строки

 - **ordinal**: возвращает порядковый номер константы
```
enum class Day(val value: Int){
    MONDAY(1), TUESDAY(2), WEDNESDAY(3),
    THURSDAY(4), FRIDAY(5), SATURDAY(6),
    SUNDAY(7)
}
 
fun main() {
 
    val day1: Day = Day.FRIDAY
    println(day1.name)        // FRIDAY
    println(day1.ordinal)     // 4
}
```
Кроме того, в Kotlin нам доступны вспомогательные функции:

 - **valueOf(value: String)**: возвращает объект перечисления по названию константы

 - **values()**: возвращает массив констант текущего перечисления
```
fun main() {
 
    for(day in Day.values())
        println(day)
 
    println(Day.valueOf("FRIDAY"))
}
```

#### Анонимные классы и реализация интерфейсов
Константы перечисления могут определять анонимные классы, которые могут иметь собственные методы и свойства или реализовать абстрактные методы класса перечисления:

```
enum class DayTime{
    DAY{
        override val startHour = 6
        override val endHour = 21
        override fun printName(){
            println("День")
        }
    },
    NIGHT{
        override val startHour = 22
        override val endHour = 5
        override fun printName(){
            println("Ночь")
        }
    };
    abstract fun printName()
    abstract val startHour: Int
    abstract val endHour: Int
}
 
fun main() {
 
    DayTime.DAY.printName()     // День
    DayTime.NIGHT.printName()   // Ночь
 
    println("Day from ${DayTime.DAY.startHour} to ${DayTime.DAY.endHour}")
 
}
```
В данном случае класс перечисления DayTime определяет абстрактный метод printName() и две переменных - startHour (начальный час) и endHour (конечный час). А константы определяют анонимные классы, которые реализуют эти свойства и функцию.

Также, классы перечислений могут применять интерфейсы. Для этого для каждой константы определяется анонимный класс, который содержат все реализуемые свойства и функции:
```
interface Printable{
    fun printName()
}
enum class DayTime: Printable{
    DAY{
        override fun printName(){
            println("День")
        }
    },
    NIGHT{
        override fun printName(){
            println("Ночь")
        }
    }
}
 
fun main() {
 
    DayTime.DAY.printName()     // День
    DayTime.NIGHT.printName()   // Ночь
}
```

#### Хранение состояния 
Нередо перечисления применяются для хранения состояния в программе. И в зависимоси от этого состояния мы можем направить действие программы по определенному пути. Например, определим перечисление, которое представляет арифметические операции, и функцию, которая в зависимости от переданной операции выполняет то или иное действие:
```
fun main() {
 
    println(operate(5, 6, Operation.ADD))         // 11
    println(operate(5, 6, Operation.SUBTRACT))   // -1
    println(operate(5, 6, Operation.MULTIPLY))   // 30
}
enum class Operation{
 
    ADD, SUBTRACT, MULTIPLY
}
fun operate(n1: Int, n2: Int, op: Operation): Int{
 
    when(op){
        Operation.ADD -> return n1 + n2
        Operation.SUBTRACT -> return n1 - n2
        Operation.MULTIPLY -> return n1 *n2
    }
}
```
Функция operate() принимает два числа - операнды операции и тип операции в виде перечисления Operation. И в зависимоси от значения перечисления возвращает либо сумму, либо разность, либо произведение двух чисел.