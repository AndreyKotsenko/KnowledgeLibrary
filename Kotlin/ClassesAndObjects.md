# ООП. Классы и обьекты

В Kotlin как и в Java присутствует принцип ООП. Это означает что мы можем создавать классы, а на их основе создавать обьекты. Суть ООП заключается в том что бы перенести обьекты в программы, и взаимодействовать с ними будто с реальными обьектами. 

### Класс
Есть хорошая аналогия. Класс - это рецепт, а блюдо это обьект. Так вот мы создаем классы определенных обьектов и описываем их состояние как переменные класса и их поведение как методы класса. 
Пример создания класса:
```
class User
```
```
class User {

}
```
```
class User {
  var age: Int = 10
  var name: String = "Andrey"
  
  fun printUser() {
      println("$name")
  }
}
```

В приведенных выше примерах было показано как мы можем создавать классы в Kotlin. Первый и второй примеры, это примеры пустых классов, в которых ничего нету, но они были приведенны для того что бы знать что так тоже можно делать. А вот 3 пример содержит уже у себя две переменные или как их принято называть в классах - **поля**, и одну функцию которую принято называть как **метод**.

Теперь мы можем создать обьект этого класса и обратится к полям класса и его методам. Пример:
```
fun main(args: Array<String>) {
  andrey = User()
  println(andrey.age)
  andrey.printUser()
}
```

### Конструктор
Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. Для определения конструкторов применяется ключевое слово **constructor**.

Классы в Kotlin могут иметь один **первичный** конструктор (primary constructor) и один или несколько **вторичных** конструкторов (secondary constructor).

**Первичный** конструктор является частью заголовка класса и определяется сразу после имени класса:
```
class User constructor(_firstName: String, _secondName: String) {
}
```

Конструкторы, как и обычные функции, могут иметь параметры. Так, в данном случае конструктор имеет параметры __firstName, _secondName , которые представляет тип String. Через параметры конструктора мы можем передать извне данные и использовать их для инициализации объекта. При этом первичный конструктор в отличие от функций не определяет никаких действий, он только может принимать данные извне через параметры.

Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, как в данном случае, то ключевое слово constructor можно опустить:
```
class User(_firstName: String, _secondName: String) {
}
```

Что делать с полученными через конструктор данными? Мы их можем использовать для инициализации свойств класса. Для этого применяются блоки инициализаторов:
```
class User(_firstName: String, _secondName: String) {

    var firstName: String
    var secondName: String

    init {
        firstName = _firstName
        secondName = _secondName
    }
}
```

Важно учитывать, что если мы определили первичный конструктор, то мы не можем использовать конструктор по умолчанию, который генерируется компилятором. Для создания объекта обязательно надо использовать первичный конструктор, если он определен в классе.

Стоит отметить, что в классе может быть определено одновременно несколько блоков инициализатора.

Также стоит отметить, что в данном случае в инициализаторе нет смысла, так как параметры первичного конструктора можно нарямую передавать свойствам:
```
class User(_firstName: String, _secondName: String) {

    var firstName: String = _firstName
    var secondName: String = _secondName
}
```

Так же мы можем задать дефолтные значения для параметров конструктора. В таком случае мы можем и не передавать тот параметр который имеет дефолтное значение:
```
class User(_firstName: String = "Andrey", _secondName: String = "Kotsenko") {

    var firstName: String = _firstName
    var secondName: String = _secondName
}
```

Примеры создания обьектов:
```
fun main(args: Array<String>) {
   user_1 = User()
   user_2 = User("Vadim")
   user_3 = User("Vadim", "Godrt")
}
```
Все три варианта отработают.


Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить дополнительные параметры, через которые можно передавать данные для инициализации объекта.

Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова **this**:
```
class User(_firstName: String = "Andrey", _secondName: String = "Kotsenko") {

    var firstName: String = _firstName
    var secondName: String = _secondName
    
    constructor(): this("Peter", "Patrik") {
        println("All done!")
    }
}
```

### Геттеры и сеттеры
Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:
```
var имя_свойства[: тип_свойства] [= инициализатор_свойства]
    [getter]
    [setter]
```

Инициализатор, геттер и сеттер свойства необязательны. Указывать тип свойства также необязательно, если он может быть выведен их значения инициализатора или из возвращаемого значения геттера.

Геттеры и сеттеры необязательно определять именно для свойств внутри класса, они могут также применяться к переменным верхнего уровня.

Сеттер определяет логику установки значения переменной. То есть перед тем как присвоить переменной некое значение, мы можем реализовать проверку в сетере.

Геттер управляет получением значения свойства и определяется с помощью ключевого слова get.

В этих методах есть ключевое слово **field**.
Пример геттера и сеттера:
```
class User constructor(_firstName: String = "Peter", _secondName: String) {

    var firstName: String = _firstName
    var secondName: String = _secondName

    var login: String? = null
        set(value) {
            field = value
            println("$field")
        }
        get(){
            val loginField = field ?: "none"
            println("I take variable: $loginField")
            return field
        }
}
```

Геттер может возвращать вычисляемые значения, которые могут задействовать несколько свойств. Так же геттер можно определять в одну строчку:
```
class User constructor(_firstName: String = "Peter", _secondName: String) {

    var firstName: String = _firstName
    var secondName: String = _secondName
    
    val fullname: String
        get() = "$firstName $secondName"
    
}
```

### Модификаторы доступа

Все используемые типы, а также компоненты типов (классы, объекты, интерфейсы, конструкторы, функции, свойства) имеют определеннй уровень видимости, определяемый модификатором видимости (модификатором доступа). Модификатор видимости определяет, где те или иные типы и их компоненты доступны и где их можно использовать. В Kotlin есть следующие модификаторы видимости:

 - **private**: классы, объекты, интерфейсы, а также функции и свойства, определенные вне класса, с этим модификатором видны только в том файле, в котором они определены. Члены класса с этим модификатором видны только в рамках своего класса

 - **protected**: члены класса с этим модификатором видны в классе, в котором они определены, и в классах-наследниках

 - **internal**: классы, объекты, интерфейсы, функции, свойства, конструкторы с этим модификатором видны в любой части модуля, в котором они определены. Модуль представляет набор файлов Kotlin, скомпилированных вместе в одну структурную единицу. Это может быть модуль IntelliJ IDEA или проект Maven

 - **public**: классы, функции, свойства, объекты, интерфейсы с этим модификатором видны в любой части программы. (При этом если функции или классы с этим модификатором определены в другом пакете их все равно нужно импортировать)

Для установки уровня видимости модификатор ставится перед ключевыми словами var/val/fun в самом начале определения свойства или функции.

Если модификатор видимости явным образом не указан, то применяется модификатор **public**.

Если же к свойствам и методам применяется модификатор **private**, то к ним нельзя будет обратиться извне - вне данного класса.

Модификатор **protected** определяет свойства и функции, которые из вне класса видны только в классах-наследниках.


Конструкторы как первичные, так и вторичные также могут иметь модификаторы. Модификатор указывается перед ключевым словом constructor. По умолчанию они имеют модификатор public. Если для первичного конструктора необходимо явным образом установить модификатор доступа, то конструктор определяется с помощью ключевого слова constructor:
```
fun main() {
 
    // val bob  = Person("Bob")    // Так нельзя - конструктор private
}
open class Person private constructor(val name:String){
 
     fun printPerson(){
        println("Name: $name")
    }
}
// class Employee(name:String) : Person(name)  // так нельзя - конструктор в Person private
```

Стоит отметить, что в данном случае, поскольку конструктор приватный мы не можем его использовать вне класса ни для создания объекта класса в функции main, ни при наследовании. Но мы можем использовать такой конструктор в других конструкторах внутри класса:
```
fun main() {
 
    val tom = Employee("Tom", 37)
    tom.printPerson()
}
open class Person private constructor(val name:String){
 
    var age: Int = 0
    protected constructor(_name:String, _age: Int): this(_name){    // вызываем приватный конструктор
        age = _age
    }
     fun printPerson(){
        println("Name: $name Age: $age")
    }
}
class Employee(name:String, age: Int) : Person(name, age)
```
Здесь вторичный конструктор класса Person, который имеет модификатор protected (то есть доступен в текущем классе и классах-наследниках) вызывает первичный конструктор класса Person, который имеет модификатор private.


<hr/>

Классы, а также переменные и функции, которые определены вне других классов, также могут иметь модификаторы public, private и internal.

Допустим, у нас есть файл **base.kt**, который определяет одноименный пакет:
```
package base
 
private val privateVal = 3
val publicVal = 5
 
private class PrivateClass(val name: String)
class PublicClass(val name:String)
 
private fun privateFun(){
    println("privateFn")
    println(privateVal)
    val privateClass= PrivateClass("Tom")
}
 
fun publicFun(){
    println("publicFn")
    println(privateVal)
    val privateClass= PrivateClass("Tom")
}
```
Внутри данного файла мы можем использовать его приватные переменные, функции классы. Однако при подключении этого пакета в другие файлы, приватные переменные, функции и классы будут недоступны.

Однако даже внутри одного файла есть ограничения на использование приватных классов:
```
package email
 
private class Message(val text: String)
 
fun send(message: Message, address : String){
    println("Message `${message.text}` has been sent to $address")
}
```

Здесь мы столкнемся с ошибкой, так как публичная функция не может принимать параметр приватного класса. И в данном случае нам надо либо сделать класс Message публичным, либо функцию send приватной.