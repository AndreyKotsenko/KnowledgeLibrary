# Массивы и другие структуры данных
Как и в других языках, у нас есть массивы и структуры данных. До этого мы работали с переменными разных типов которые хранили одно значение. Теперь же мы будем работать с переменными которые будут хранить массивы или другие структуры данных. То есть будут хранить несколько значений одного или разных типов данных.

### Any
В Kotlin есть специальный тип **Any** который означает что он может принимать любой тип данных. Этот тип данных может использоваться в массивах и в структурах данных что означает что они могут хранить разнообразные значения, разных типов данных. Такого поведения нету в Java.

### Array
**Array** - это обычный массив. То есть структура данных которая хранит в себе определенное количество элементов определенного типа, или раззных типов данных.

Массивы можно создать двумя путями:
 - через конструктор Array
 - через методы (arrayOf и т д)

Создание через конструктор:
```
var items_via_constructor: Array<Int> = Array(10, { i++ * 2})
```
В данном случае мы создаем массив на 10 элементов, о чем указываем в первом параметре, и эти элементы определяються по формуле указаной как второй параметр.

Создание через метод:
```
var items_via_method: Array<Int> = arrayOf(5, 7, 12, 4, 0, 1)
```


Так же у массивов есть метод возвращающий диапазон индексов с которым можно взаимодействовать:
```
    for(i in items_via_constructor.indices) {
        println(items_via_constructor[i])
    }
```

В массивов есть множество методов которые выполняют определеный функции, к примеру, вернуть значение по индексу, или получить размер массива, или заменить элемент по индексу и т д. Вот примеры некоторых:
```
    println(items_via_method[0])
    println(items_via_method.get(1))
    println(items_via_method.size)
    println(items_via_method.set(0, 45))
```

Так же есть один интересный способ как проверить, присутствует ли элемент в массиве:
```
    println(4 in items_via_constructor)
    println(3 in items_via_constructor)
```
Если элемент присутствует то будет возвращено **true**, иначе **false**.

Если мы хотим перебрать массив, то помимо стандартных циклов так же есть встроенные циклы, для перебора элементов массива или перебор элементов и их индексов. Примеры:
```
    println("\nPrint array via for-each:")
    items_via_method.forEach { el ->
        println(el)
    }

    println("\nPrint array via loop for-each with index")
    items_via_method.forEachIndexed() { index, el ->
        println("$el with index $index")
    }
```

Массивы так же могут быть как одномерные (все выше описанные) так и многомерные. Вот пример создания двухмерного массива:
```
    val table: Array<Array<Int>> = Array(3, {Array(3, {0}) })
    table[0] = arrayOf(1, 2, 3)
    table[1] = arrayOf(4, 5, 6)
    table[2] = arrayOf(7, 8, 9)
```

Перебрать такой массив можно следующим образом:
```
    println("\nPrint array: ")
    for( row in table) {
        for(cell in row) {
            print("$cell \t")
        }
        println()
    }
```

Еще одна особенность массивов заключается в том что их можно складывать. Как результат мы получим новый массив который будет состоять из элементов первого и второго массива. Так же мы можем добавлять элементы в массив используя **+=**. Примеры:
```
    var first = arrayOf(1, 2, 3)
    var second = arrayOf(4, 5, 6)
    var third = first + second
    third += 7
```

### Колекции 
Коллекции в Kotlin используют множество различных интерфейсов: Iterable, Collection, Set, List, MutableIterable, MutableCollection и др.

В Kotlin нет собственных коллекций, только Java-коллекции. Но при этом в Kotlin они обладают более широкими возможностями, используя расширения. Например, вы можете узнать последний элемент списка или найти максимальное значение в коллекции чисел.

Важная особенность - в Kotlin интерфейсы явно разделены на две группы - изменяемые и неизменяемые. Старайтесь всегда использовать неизменяемые коллекции с доступом для чтения. Если вам нужно изменять коллекцию, то тогда выбирайте другой вариант. Здесь не надо путать с var и val. Если вы создадите список для чтения и привяжете его к переменной var, список всё равно нельзя будет изменить после создания.

### List
Списки очень похожи на массивы, вот только списки по большей части предназначены для чтения. Но это не значит что нельзя добавлять или удалять из них элементы, все зависит от того каким способом был создан список, ибо он может быть изменяемый и неизменяемый. 

Создание неизменяемого списка:
```
    var list_items: List<Int> = listOf(5, 7, 12, 1, 4, 0, 1)
```
Таким образом у нас будет список с которого мы сможем получать элементы но не сможем удалять или добавлять их.

Создание изменяемого списка:
```
    var mutable_list_items = mutableListOf<Any>(5, 7, 12, 1, 4, 0, 1)
```
В такой список можно добавлять новые элементы или же целые списки. Пример:
```
    mutable_list_items.add("Dogs")
    mutable_list_items.addAll(4, list_items)
```
Мы смогли добавить строку в список так как его тип данных **Any**.

Перебирать списки можно все через те же циклы:
```
    println("\nPrint mutable list via loop for-each with index:")
    mutable_list_items.forEachIndexed() { key, value ->
        println("$key - $value")
    }
```

Все эти списки унаследуються от множества интерфейсов и классов. Полную структуру всех унаследований будет предоставлено дальше.

### Set
Сет - колекция, суть которой заключается в том что все ее элементы уникальны, даже если мы создадим много повторяющихся элементов, то в колекции они будут храниться только в единственном варианте. 
Пример создания неизменяемой последовательности:
```
    var numbers = setOf(5, 6, 7, 6, 6, 7, 5)

    println("\nPrint set: ")
    numbers.forEach{ el -> println("$el")} // [5, 6, 7]
```

Так же с сетами можно проводить операции пересечения, обьединения, вычитывания. Пример:
```
    val people = setOf("Tom", "Sam", "Bob", "Mike")
    val employees = setOf("Tom", "Sam", "Kate", "Alice")

    val all = people.union(employees)
    val common = people.intersect(employees)
    val different = people.subtract(employees)

    println(all)        // [Tom, Sam, Bob, Mike, Kate, Alice]
    println(common)     // [Tom, Sam]
    println(different)  // [Bob, Mike]
```

То что примечательно и удивительно в сравнении с Java, так это то что эти слова можно использовать как обычные операции:
```
    val all_ex = people union employees
    val common_ex = people intersect employees
    val different_ex = people subtract employees

    println(all_ex)        // [Tom, Sam, Bob, Mike, Kate, Alice]
    println(common_ex)     // [Tom, Sam]
    println(different_ex)  // [Bob, Mike]
```

Создание изменяемого сета и изминение его:
```
    val numbers_mutable: MutableSet<Int> = mutableSetOf(35, 36, 37)

    println(numbers_mutable.add(2))
    println(numbers_mutable.addAll(setOf(4, 5, 6)))
    println(numbers_mutable.remove(36))

    for (n in numbers){ println(n) }    // 35 37 2 4 5 6
```

### Map
Карта - это колекция, суть которой состоит в том что ее данные хранятся в виде "ключ-значение", при этом что ключ так и значение могут быть разных типов.
Пример:
```
    val map_of_people = mapOf(1 to "Tom", 5 to "Sam", 8 to "Bob")
    for(person in map_of_people){
        println("${person.key} - ${person.value}")
    }
    println(map_of_people)     // {1=Tom, 5=Sam, 8=Bob}
    println(map_of_people.get(8)) // Bob
    println(map_of_people[5]) // Sam
    println(map_of_people[50]) // null
    println(map_of_people.getOrDefault(70, "default")) // "default"
    println(map_of_people.getOrElse(70){"Not Found"}) // "Not Found"
```
В данном примере мы создали неизменяемую карту и вывели ее через цикл **for**. После чего были показаны разные выводы информации. Функция **getOrDefault()** получает значение по ключу если он существует, иначе выводит значение указаное в втором параметре. Функция **getOrElse()** аналогично.

Так же мы можем отдельно вывести значения или ключи нашей карты:
```
    println(map_of_people.values)
    println(map_of_people.keys)
```

Так же как и в других колекциях, мы можем создать изменяемую карту:
```
    var mutable_map_items = mutableMapOf<String, Any>("name" to "Bob", "age" to 1, "isHasCar" to true)
```

Ниже будут показаны спобобы добавления, изминения и удаления данных из карты:
```
    // add data
    mutable_map_items.put("city", true)

    // change data
    mutable_map_items.set("city", 10)
    mutable_map_items["city"] = 15

    // remove data
    mutable_map_items.remove("isHasCar")

    // for-each for map
    println("\nPrint map via loop for-each")
    mutable_map_items.forEach {key, value -> println ("$key - $value")}
```

### Sequence
Наряду с коллекциями Kotlin предоставляет еще один тип наборов элементов – последовательности (sequences). Последовательности предоставляют похожую функциональность, что и интерфейс Iterable, который реализуется типами коллекций. Ключевая разница состоит в том, как обрабатываются элементы последовательности при применении к ним набора операций.
Для создания последовательности можно использовать такую конструкцию:
```
    val sequence_people = sequenceOf("Tom", "Sam", "Bob")
    println(sequence_people.joinToString())  // Tom, Sam, Bob
```

Так же можно преобразовывать списки и массивы в последовательности:
```
    val sequence_employees = listOf("Tom", "Sam", "Bob") // объект List<String>
    val sequence_emplo = sequence_employees.asSequence()         //тип Sequence<String>
    println(sequence_emplo.joinToString())    // Tom, Sam, Bob
```

И так же мы можем генерировать последовательности за функцией:
```
    var number = 0
    val suquece_numbers = generateSequence{ number += 2; number}
    println(suquece_numbers.take(5).joinToString())    //  2, 4, 6, 8, 10
```

Четвертый способ представляет применение функции **sequence()**. В этой функции можно генерировать элементы последовательности с помощью функций **yield()** и **yieldAll()**:
```
    val yield_numbers = sequence {
        yield(1)
        yield(4)
        yield(7)
    }
    println(yield_numbers.joinToString())    // 1, 4, 7
```

Функция yield() фактически возвращает во вне некоторое значение, которое ей передается через параметр. То есть при первом обращении к функции sequence сработает вызов yield(1), который возвратит значение 1. При втором обращении сработает вызов yield(4), который возвратит 4. И при третьем обращении сработает вызов yield(7). Таким образом, последовательность будет содержать 3 элемента: 1, 4, 7.

Можно создать и бесконечную последовательность:
```
    val infinity = sequence {
        var start = 0
        while(true) yield(start++)
    }
    println(infinity.take(5).joinToString())    // 0, 1, 2, 3, 4
```

Если надо создать последовательности на основе другой последовательности или коллекции, то удобнее источник данных передать в функцию **yieldAll()**:
```
val personal = sequence {
    val data = listOf("Alice", "Kate", "Ann")
    yieldAll(data)
}
println(personal.joinToString())    // Alice, Kate, Ann
```


И последовательности, и коллекции, которые реализуют интерфейс Iterable, по сути представляют набор элементов. Более того предоставляют похожий набор операций для обработки элементов. Но отличие состоит, как эти операции обрабатывают элементы при применении сразу нескольких операций.

Так, при применении набора операций к коллекции Iterable каждая отдельная операция возвращает промежуточный результат - промежуточную коллекцию. А при обработке последовательности весь набор операций выполняется только тогда, когда требуется конечный результат обработки.

Также меняется порядок применения операций. Коллекция применяет каждую операцию последовательно к каждому элементу. То есть сначала выполняет первую операцию для всех элементов, потом вторую операцию для элементов коллекции, полученных после первой операции. И так далее.

Последовательность применяет весь набор операций отдельно к каждому элементу. То есть сначала весь набор операций применяется к первому элементу, потом ко второму элементу и так далее. Таким образом, последовательность позволяет избежать создания помежуточных коллекций и в тоже время повышают производительность при выполнении набора операций особенно для большого набора данных. Однако при небольших наборах данных и малом количестве операций может быть эффективнее использовать коллекции Iterable.